rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is admin (developer email).
    // Some auth tokens may not include the email field, so we also
    // fallback to checking the user's document email field.
    function isAdmin() {
      return request.auth != null && (
             // Preferred: email present in auth token
             request.auth.token.email == 'hotcupofjoe2013@gmail.com' ||
             // Fallback: check the user's profile document email
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.email == 'hotcupofjoe2013@gmail.com'
      );
    }
    
    // Helper function to check if user is a librarian (from user doc)
    function isLibrarian() {
      return request.auth != null && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.librarian == true;
    }
    
    // Helper function to check if user is pro (from user doc)
    function isPro() {
      return request.auth != null && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.proStatus == true;
    }

    // Community books collection - publicly readable catalog.
    // Books are considered catalog metadata and can be read by any client.
    // Authenticated users can create new books (from add book flow).
    // Librarians can update/curate. Admins can delete.
    match /books/{bookId} {
      // Public read for book metadata
      allow read: if true;
      
      // Allow authenticated users to CREATE new books when adding to their library
      // Validate that required fields are present
      allow create: if request.auth != null && 
                       request.resource.data.keys().hasAll(['title', 'authors', 'id']) &&
                       request.resource.data.title is string &&
                       request.resource.data.authors is list;
      
      // Allow librarians and admins to UPDATE books (for curation)
      allow update: if request.auth != null && (isLibrarian() || isAdmin());
      
      // Only admins can delete
      allow delete: if isAdmin();
    }

    // Curated collections - visibility-based read rules.
    // Each collection document may include a `visibility` field with values
    // like 'public' or 'pro'. Public collections are readable by everyone.
    // Pro collections require pro status, librarian, or admin role.
    match /collections/{collectionId} {
      // Single document reads: allow if the document is public or the
      // caller is pro/librarian/admin
      allow get: if resource.data.visibility == 'public' ||
                 (request.auth != null && (isPro() || isLibrarian() || isAdmin()));

      // Queries (list): Firestore requires that the query itself constrains
      // results to documents the user is allowed to read. Allow listing
      // when the client filters for public collections, or when the caller
      // has pro/librarian/admin status
      allow list: if (request.query != null &&
                      request.query.where('visibility', '==', 'public')) ||
                     (request.auth != null && (isPro() || isLibrarian() || isAdmin()));

      allow create, update, delete: if false; // Admin-only (via backend)
    }

    // Per-user documents (profile) and nested collections
    match /users/{userId} {
      // Allow any authenticated user to READ any user doc (public profile metadata)
      allow read: if request.auth != null;
      // Allow the user to create/update/delete their own top-level user doc.
      // Also allow the admin (developer email) to write user docs so developer
      // tools can toggle librarian/pro status without Cloud Functions.
      // Using write (covers create, update, and set with merge) for flexibility
      allow write: if request.auth != null && (
        request.auth.uid == userId || isAdmin()
      );

      // User's personal library (nested collection) - only the user can read/write
      // Allows updating fields like 'ownership', 'genres', 'tropes', 'warnings', etc.
      match /library/{bookId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // User's personal lists (shelves) - only the user can read/write
      match /lists/{listId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Social / Friends collection - per-user friendships
    // This section permits the typical client-side friend request + accept
    // flow without requiring server-side functions. It is intentionally
    // narrowly scoped: only authenticated users may create friend documents
    // and updates are allowed only for the owner or for the friend when
    // transitioning a pending request to accepted/declined.
    match /users/{userId}/friends/{friendId} {
      // Allow either party to read the friendship doc (owner or the friend)
      allow read: if request.auth != null && (request.auth.uid == userId || request.auth.uid == friendId);

      // Allow the friend (sender) to create a friend document under the
      // recipient's friends collection (doc id == sender uid).
      // Also allow the recipient (owner) to create the reciprocal document
      // when they are performing the accept action (setting status -> 'accepted').
      // This permits the common client-side two-doc batch used when accepting
      // a friend request without requiring server-side functions.
      allow create: if request.auth != null && (
        request.auth.uid == friendId ||
        (
          request.auth.uid == userId &&
          request.resource.data.status == 'accepted'
        )
      );

      // Allow updates in two narrow cases:
      //  1) The owner (userId) may accept/decline a pending incoming request.
      //  2) The friend (friendId) may mark the recipient's copy as accepted
      //     when performing a reciprocal update as part of a client-side
      //     batch (this supports the atomic two-doc client batch used by
      //     the app when accepting requests).
      allow update: if request.auth != null && (
        // Owner accepting/declining their incoming request
        (request.auth.uid == userId && resource.data.status == 'pending' && request.resource.data.status in ['accepted', 'declined'])
        // Friend performing the reciprocal accept (pending -> accepted)
        || (request.auth.uid == friendId && resource.data.status == 'pending' && request.resource.data.status == 'accepted')
      );

      // Allow deletion by either side (owner or friend cancelling)
      allow delete: if request.auth != null && (request.auth.uid == userId || request.auth.uid == friendId);
    }

    // Affiliate clicks tracking - authenticated write, read for owner or admin
    match /affiliate_clicks/{clickId} {
      // Allow authenticated users to log their own affiliate clicks
      allow create: if request.auth != null;
      // Allow users to read their own clicks, or admins can read all
      allow read: if request.auth != null && 
                     (resource.data.userId == request.auth.uid || isAdmin());
      allow update, delete: if false; // Read-only collection for audit purposes
    }

    // App config - admin-only writes, authenticated reads
    match /app_config/{document=**} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Default deny all other collections
    match /{document=**} {
      allow read, write: if false;
    }

    // Mapping for safe email -> uid lookups from client
    // Documents: users_by_email/{normalizedEmail} -> { uid: "<userUid>" }
    // These docs contain only the UID and are safe to make readable by clients.
    match /users_by_email/{emailId} {
      allow get: if true;
      allow list: if false;
      allow create, update, delete: if false;
    }

    // Mapping for username -> uid lookups from client
    // Documents: users_by_username/{normalizedUsername} -> { uid: "<userUid>" }
    // These docs contain only the UID and are safe to make readable by clients.
    match /users_by_username/{usernameId} {
      allow get: if true;
      allow list: if false;
      allow create, update, delete: if false;
    }
  }
}
