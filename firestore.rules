rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is admin
    function isAdmin() {
      return request.auth != null && (
        request.auth.token.admin == true ||
        request.auth.token.get('admin', false) == true
      );
    }

    // Pre-seeded books collection - make metadata publicly readable.
    // Books are considered catalog metadata and can be read by any client.
    match /books/{bookId} {
      // Public read for book metadata. If you want to restrict access to
      // book documents, change this condition accordingly.
      allow read: if true;
      allow create, update, delete: if false; // Prevent client-side modifications
    }

    // Curated collections - visibility-based read rules.
    // Each collection document may include a `visibility` field with values
    // like 'public' or 'pro'. Public collections are readable by everyone.
    // Pro collections require the calling user to have a custom `pro` claim,
    // or elevated roles like `librarian` or `admin`.
    match /collections/{collectionId} {
      // Single document reads: allow if the document is public or the
      // caller has a pro/librarian/admin custom claim.
      allow get: if resource.data.visibility == 'public' ||
                 (request.auth != null && (
                    request.auth.token.pro == true ||
                    request.auth.token.librarian == true ||
                    request.auth.token.admin == true
                 ));

      // Queries (list): Firestore requires that the query itself constrains
      // results to documents the user is allowed to read. Allow listing
      // when the client filters for public collections, or when the caller
      // has pro/librarian/admin claims which permits unfiltered lists.
      allow list: if (request.query != null &&
                      request.query.where('visibility', '==', 'public')) ||
                     (request.auth != null && (
                        request.auth.token.pro == true ||
                        request.auth.token.librarian == true ||
                        request.auth.token.admin == true
                     ));

      allow create, update, delete: if false; // Admin-only (via backend)
    }

    // Per-user documents (profile) and nested collections
    match /users/{userId} {
      // Allow any authenticated user to READ any user doc (public profile metadata)
      allow read: if request.auth != null;
      // Allow only the user to create/update/delete their own top-level user doc
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update, delete: if request.auth != null && request.auth.uid == userId;

      // User's personal library (nested collection) - only the user can read/write
      // Allows updating fields like 'ownership', 'genres', 'tropes', 'warnings', etc.
      match /library/{bookId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // User's personal lists (shelves) - only the user can read/write
      match /lists/{listId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Social / Friends collection - per-user friendships
    // Defined at top level (not nested under users) to avoid parent restrictions.
    match /users/{userId}/friends/{friendId} {
      // Allow user to read their own friend requests and accepted friends
      allow read: if request.auth != null && request.auth.uid == userId;
      
      // Allow any authenticated user to CREATE a friend request
      // (write to someone else's friends collection)
      allow create: if request.auth != null;
      
      // Allow user to UPDATE their own friend requests (accept/decline)
      allow update: if request.auth != null && request.auth.uid == userId &&
                       resource.data.status == 'pending' &&
                       request.resource.data.status in ['accepted', 'declined'];
      
      // Allow user to DELETE their own friend requests, or the sender to cancel
      allow delete: if request.auth != null && 
                       (request.auth.uid == userId || request.auth.uid == friendId);
    }

    // Affiliate clicks tracking - authenticated write, read for owner or admin
    match /affiliate_clicks/{clickId} {
      // Allow authenticated users to log their own affiliate clicks
      allow create: if request.auth != null;
      // Allow users to read their own clicks, or admins can read all
      allow read: if request.auth != null && 
                     (resource.data.userId == request.auth.uid || isAdmin());
      allow update, delete: if false; // Read-only collection for audit purposes
    }

    // App config - admin-only writes, authenticated reads
    match /app_config/{document=**} {
      allow read: if request.auth != null;
      allow write: if isAdmin();
    }

    // Default deny all other collections
    match /{document=**} {
      allow read, write: if false;
    }

    // Mapping for safe email -> uid lookups from client
    // Documents: users_by_email/{normalizedEmail} -> { uid: "<userUid>" }
    // These docs contain only the UID and are safe to make readable by clients.
    match /users_by_email/{emailId} {
      allow get: if true;
      allow list: if false;
      allow create, update, delete: if false;
    }
  }
}
